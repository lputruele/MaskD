Enum MSG = {null, error, reject, accept, entry};


Global lToF1,lToF2,lToF3 : MSG;


Process Leader{
	committed: BOOL;
	Initial: lToF1 == null && lToF2 == null && lToF3 == null && committed == false;
	Normative: true;
		[sendEntry1] (lToF1 == null || lToF1 == reject) && committed == false -> lToF1 = entry;
		[sendEntry2] (lToF2 == null || lToF2 == reject) && committed == false -> lToF2 = entry;
		[sendEntry3] (lToF3 == null || lToF3 == reject) && committed == false -> lToF3 = entry;
		[sendEntry1E] internal lToF1 == error && committed == false -> lToF1 = entry;
		[sendEntry2E] internal lToF2 == error && committed == false -> lToF2 = entry;
		[sendEntry3E] internal lToF3 == error && committed == false -> lToF3 = entry;
		[commitEntry] ((lToF1 == accept && lToF2 == accept) || (lToF1 == accept && lToF3 == accept) || (lToF3 == accept && lToF2 == accept)) && committed == false -> committed = true, lToF1 = null, lToF2 = null, lToF3 = null;
}

Process Follower(recChan : MSG){
	available: BOOL;
	Initial:  lToF1 == null && lToF2 == null && lToF3 == null && available;
	Normative: true;
		[receiveEntry] available && recChan == entry -> recChan = accept;
		[receiveEntry] !available && recChan == entry -> recChan = error;
		[rejectEntry] available && recChan == entry -> recChan = reject;
		[rejectEntry] !available && recChan == entry -> recChan = error;
		[crash] faulty available -> available = false;	
}



Main(){
    leader:Leader;
    f1:Follower;
    f2:Follower;
    f3:Follower;
    run leader();
    run f1(lToF1);
    run f2(lToF2);
    run f3(lToF3);
}