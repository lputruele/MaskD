Global g1g2A,g1g3A: BOOL; //Commander(g1) attack messages
Global g2g3A: BOOL; //Lieutenant1(g2) attack messages
Global g3g2A: BOOL; //Lieutenant2(g3) attack messages

Global g1g2R,g1g3R: BOOL; //Commander(g1) retreat messages
Global g2g3R: BOOL; //Lieutenant1(g2) retreat messages
Global g3g2R: BOOL; //Lieutenant2(g3) retreat messages

Global A2,A3: BOOL; //The Attack decision of each lieutenant
Global R2,R3: BOOL; //The Retreat decision of each lieutenant

Process Commander{
	s0,s1: BOOL;
	Initial: s0 && !s1;
	Normative: true;
		[sA] s0 -> g1g2A = true, g1g3A = true, s0= false, s1=true;
		[sR] s0 -> g1g2R = true, g1g3R = true, s0= false, s1=true;
}


Process Lieutenant(attack: BOOL, retreat: BOOL, fw1A: BOOL, fw1R:BOOL, a1:BOOL, r1:BOOL, dA:BOOL, dR:BOOL){
	s0,s1,s2, isBetrayer: BOOL;
	Initial: s0 && !s1 && !s2 && !isBetrayer;
	Normative: true;
		[fA] s0 && attack && !isBetrayer -> fw1A = true, s0 = false, s1 = true;
		[fR] s0 && retreat && !isBetrayer -> fw1R = true, s0 = false, s1 = true;
		[fA] s0 && attack && isBetrayer -> fw1R = true, s0 = false, s1 = true;
		[fR] s0 && retreat && isBetrayer -> fw1A = true, s0 = false, s1 = true;
		[Betray] faulty s0 && !isBetrayer -> isBetrayer = true; 
		[Attack] s1 && !isBetrayer && ((attack && a1)) -> s1 = false, s2 = true, dA = true;
		[Retreat] s1 && !isBetrayer && ((retreat && r1)) -> s1 = false, s2 = true, dR = true;
		[Retreat] s1 && !isBetrayer && !((retreat && r1)) && !((attack && a1)) -> s1 = false, s2 = true, dR = true;

}




Main(){
    g1:Commander;
    g2:Lieutenant;
    g3:Lieutenant;
    run g1();
    run g2(g1g2A,g1g2R,g2g3A,g2g3R,g3g2A,g3g2R,A2,R2);
    run g3(g1g3A,g1g3R,g3g2A,g3g2R,g2g3A,g2g3R,A3,R3);
}