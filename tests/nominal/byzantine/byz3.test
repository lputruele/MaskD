Enum STATE = {idle,sent,finished};
Enum ORDER = {null,retreat,attack};

Global g1g2,g1g3: ORDER; //Commander(g1) messages
Global g2g3: ORDER; //Lieutenant1(g2) messages
Global g3g2: ORDER; //Lieutenant2(g3) messages

Global d2,d3: ORDER; //The decision of each lieutenant


Process Commander{
	s: STATE;
	Initial: s==idle && g1g2==null && g1g3==null && g2g3==null && g3g2==null && d2==null && d3==null;
	Normative: true;
		[sA] s == idle -> g1g2 = attack, g1g3 = attack, s = sent;
		[sR] s == idle -> g1g2 = retreat, g1g3 = retreat, s = sent;
}


Process Lieutenant(order:ORDER, fw1:ORDER, r1:ORDER, d:ORDER){
	isBetrayer: BOOL;
	s: STATE;
	Initial: s == idle && !isBetrayer && g1g2==null && g1g3==null && g2g3==null && g3g2==null && d2==null && d3==null;
	Normative: true;
		[fA] s == idle && order == attack && !isBetrayer -> fw1 = attack, s = sent;
		[fR] s == idle && order == retreat && !isBetrayer -> fw1 = retreat, s = sent;
		[fA] s == idle && order == attack && isBetrayer -> fw1 = retreat, s = sent;
		[fR] s == idle && order == retreat && isBetrayer -> fw1 = attack, s = sent;
		[Attack] s == sent && !isBetrayer && ((order==attack && r1==attack)) -> s = finished, d = attack;
		[Retreat] s == sent && !isBetrayer && ((order==retreat && r1==retreat)) -> s = finished, d = retreat;
		[Retreat] s == sent && !isBetrayer && !((order==retreat && r1==retreat)) && !((order==attack && r1==attack)) -> s = finished, d = retreat;

}




Main(){
    g1:Commander;
    g2:Lieutenant;
    g3:Lieutenant;
    run g1();
    run g2(g1g2,g2g3,g3g2,d2);
    run g3(g1g3,g3g2,g2g3,d3);
}